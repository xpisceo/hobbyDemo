/********************************************************************
	created:	2009-6-10
	author:		Fish (于国平)
	svn:		https://easygameserver.svn.sourceforge.net/svnroot/easygameserver/
	purpose:	Hash表
	todo:		对Node使用ObjectPool
*********************************************************************/
#pragma once

#include <vector>
#include <string>
using namespace std;

#include "WeDebugUtil.h"

namespace We
{
	/// 提供一些常用Hash函数
	class HashUtil
	{
	public:
		static inline unsigned int HashString( const char* key )
		{
			Assert(key != 0);
			unsigned int h = 0;
			for (; *key; key++)
			{
				h = (h<<2) + h + *key;
			}
			return h;
		}
		static inline unsigned int HashString( string& key )
		{
			return HashString( key.c_str() );
		}

		static inline unsigned int HashWstring( const wchar_t* key )
		{
			Assert(key != 0);
			unsigned int h = 0;
			for (; *key; key++)
			{
				h = (h<<2) + h + *key;
			}
			return h;
		}
		static inline unsigned int HashWstring( wstring& key )
		{
			return HashWstring(key.c_str());
		}

		static inline unsigned int HashString_Lower( const char* key )
		{
			static unsigned char _HashString_Lower_values[256] = {
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
				0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
				0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
				0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
				0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
				0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
				0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
				0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
				0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
				0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
				0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
				0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
				0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
				0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
				0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
				0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
				0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
				0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
				0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
				0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
				0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
				0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
				0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
				0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
				0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
				0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,	
			};
			Assert(key != 0);
			unsigned int h = 0;
			for (; *key; key++)
			{
				h = (h<<2) + h + _HashString_Lower_values[(unsigned char)(*key)];
			}
			return h;
		}
		static inline unsigned int HashString_Lower( string& key )
		{
			return HashString_Lower( key.c_str() );
		}

		static inline unsigned int HashWstring_Lower( const wchar_t* key )
		{
			static unsigned short _HashWstring_Lower_values[256] = {
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
				0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
				0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
				0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
				0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
				0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
				0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
				0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
				0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
				0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
				0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
				0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
				0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
				0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
				0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
				0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
				0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
				0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
				0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
				0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
				0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
				0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
				0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
				0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
				0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
				0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,	
			};
			Assert(key != 0);
			unsigned int h = 0;
			for (; *key; key++)
			{
				h = (h<<2) + h + _HashWstring_Lower_values[(unsigned short)(*key)];
			}
			return h;
		}
		static inline unsigned int HashWstring_Lower( wstring& key )
		{
			return HashWstring_Lower(key.c_str());
		}


	};

	/// 解决冲突的方法:　单向链表
	/// 删除指针数据的方法:
	/*
	class Data
	{
		......
	};
	typedef HashTable<Data*,data_hash_function> DataHashTable;
	void DestroyDatas( const DataHashTable& table )
	{
		for( unsigned int i=0; i<table.Size(); ++i )
		{
			const DataHashTable::Node& node = table.Get( i );
			DataHashTable::Node* p = (DataHashTable::Node*)(&node);
			DataHashTable::Node* next = node.pNext;
			while ( p != 0 && p->data != 0 )
			{
				delete p->data;
				p->data = 0;
				p = next;
				if( next != 0 )
					next = next->pNext;
			}
		}
	}
	inline void DestroyData( Data* p )
	{
		delete p;
		p = 0;
	}
	void main()
	{
		DataHashTable data_table;
		......
		/// 方式1
		data_table.Clear( DestroyData );
		/// 方式2
		// DestroyDatas( data_table )
		// data_table.Clear();
	}
	*/

	template <class T, unsigned int (*hash_function)( T& ) >
	class HashTable
	{
	public:
		struct Node
		{
			Node() : null(true),pNext(0) {}
			bool    null;
			T		data;
			Node*	pNext;
		};

		HashTable()
		{

		}

		/*!
		\brief 
			构造函数
		\param  
			size : 大小
		*/
		HashTable( unsigned int size)
		{
			Assert( size>0 );
			m_Nodes.resize( size );
		}

		/*!
		\brief 
			析构函数,清空所有结点
		\param   
		*/
		~HashTable()
		{ 
			Clear();
		}

		/*!
		\brief 
			初始化HashTable
		\param  
			size : 大小
		*/
		void Initialize( unsigned int size )
		{
			Assert( size>0 );
			Clear();
			m_Nodes.resize( size );
		}

		/*!
		\brief 
			HashTable的大小
		\param   
		*/
		size_t Size() const
		{
			return m_Nodes.size();
		}

		/*!
		\brief 
			返回一个节点
		\param   
			index : 在HashTable里的索引
		*/
		const Node& GetNode( unsigned int index ) const
		{
			Assert( index < Size() );
			return m_Nodes[index];
		}

		//T GetData( unsigned int index ) const
		//{
		//}

		/*!
		\brief 
			添加一个对象,如果Hash值冲突,则在已有节点后面添加后续节点
		\param   
			data : 对象
		*/
		unsigned int Add( T data )
		{
			unsigned int index =  hash_function( data );
			if( index > 0 )
				index = index % Size();
			if( m_Nodes[index].null )
			{
				m_Nodes[index].data = data;
				m_Nodes[index].null = false;
			}
			else
			{
				Node* p = &m_Nodes[index];
				while( p->pNext != 0 )
				{
					p = p->pNext;
					//if( p->data == empty_value )	// 已有空位
					//{
					//	p->data = data;
					//	return index;
					//}
				}
				p->pNext = new Node();	// 新增一个列表节点
				p->pNext->data = data;
				p->pNext->null = false;
				p->pNext->pNext = 0;
			}
			return index;
		}

		/*!
		\brief 
			移除一个对象
		\param   
			data : 对象
		*/
		bool Remove( T data )
		{
			unsigned int index =  hash_function( data );
			if( index > 0 )
				index = index % Size();
			Node* p = &m_Nodes[index];
			Node* pPrev = 0;
			while( p != 0 )
			{
				if( p->data == data )
				{
					if( pPrev == 0 )
					{
						p->null = true;
					}
					else
					{
						pPrev->pNext = p->pNext;
						delete p;
						p = 0;
					}
					//p->data = empty_value;	//节点不删除,设置成空位
					return true;
				}
				pPrev = p;	//记录上一个节点
				p = p->pNext;
			}
			return false;
		}

		/*!
		\brief 
			清空所有节点
		\param   
		*/
		void Clear( void (*OnRemoveData)( T ) = 0 )
		{
			for( unsigned int i=0; i<Size(); ++i )
			{
				Node* p = &m_Nodes[i];
				if( OnRemoveData != 0 && !p->null )
					OnRemoveData( p->data );
				/// 清空子节点
				if( p->pNext != 0 )
				{
					p = p->pNext;
					Node* next = p->pNext;
					while( p != 0 )
					{
						if( OnRemoveData != 0 && !p->null )
							OnRemoveData( p->data );
						delete p;
						p = next;
						if( p != 0 )
							next = p->pNext;
					}
				}
			}
			m_Nodes.clear();
		}

	private:
		vector<Node>	m_Nodes;
	};
}
